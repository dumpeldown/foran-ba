\chapter{Implementierung}
\label{chap:implementierung}
In diesem Kapitel wird die praktische Umsetzung der im Methodikteil beschriebenen Ansätze detailliert erläutert. Der Schwerpunkt liegt dabei auf der Anwendung und Integration der empirischen Methode \gls{acema}. Außerdem wird beschrieben, wie und wo die Integration von \gls{cvss} Daten vorgenommen wurde. Weiterhin wird auf die Visualisierung des Angriffspfads eingegangen und erklärt, welche Tools dafür eingesetzt wurden. Abschließend werden zusätzliche Implementierungen vorgestellt, die die Funktionalität und Benutzerfreundlichkeit des Dashboards erweitern, darunter die Verbesserung der Zeitleistenansicht, die Vereinfachung der Datenstruktur von Artefakten sowie weiterführende Informationen zu genutzten Techniken.
\par Grundlegend besitzt das Dashboard vier verschiedene Seiten, die aus dem Hauptmenü angesteuert werden können. Die Seiten von Artefakten und Kampagnen ist dabei in die Übersichtsseite und die Detailsansicht zu trennen. In der folgenden Übersicht sind die Routen dargestellt, die im Dashboard verfügbar sind. Angegeben wird auch, welche Daten verwendet werden, um die Seite dynamisch mit Inhalt zu füllen.

\begin{itemize}
    \item \textbf{/ (Startseite):} Statische Startseite des Dashboards mit Buttons zur Navigation zu anderen Routen.
    \item \textbf{/acema (Darstellung der ACEMA Diaramme):} Enthält alle über ACEMA erstellen Diagramme als PDFs.
    \item \textbf{/mitre/kubernetes\_matrix (Kubernetes Matrix):} Visualisierung der angepassten \gls{mitre} \gls{attack} Matrix.
          \begin{itemize}
              \item \textbf{Dynamisch erzeugt aus:}
                    \begin{itemize}
                        \item \textbf{kubernetes\_matrix.tmpl:} Nutzt die Anzahl der Taktiken und Techniken zum Aufbau der Zeilen und Spalten.
                        \item \textbf{technique.partial.tmpl:} Füllt die Felder mit den in \verb|pkg/mitre/technique.go| definierten Techniken.
                    \end{itemize}
          \end{itemize}

    \item \textbf{/artifacts (Artefakte - Index):} Liefert eine Liste aller Artefakte, aller Filtermöglichkeiten und einer visuellen Darstellung auf der Zeitachse.
          \begin{itemize}
              \item \textbf{Query-Parameter (optional):}
                    \begin{itemize}
                        \item \texttt{tool\_name} - Filtert Artefakte nach dem Namen des Tools.
                        \item \texttt{tactic} - Filtert Artefakte nach der zugehörigen Taktik.
                        \item \texttt{microsoft\_technique} - Filtert Artefakte nach Microsoft-Techniken.
                        \item \texttt{start\_date} - Filtert Artefakte nach Startzeitpunk.
                        \item \texttt{end\_date} - Filtert Artefakte nach Endzeitpunkt.
                    \end{itemize}
              \item \textbf{Dynamisch erzeugt aus:}
                    \begin{itemize}
                        \item \textbf{artifacts/index.tmpl:} Nutzt die Daten aller Artefakte und die Werte der Filterparameter.
                    \end{itemize}
          \end{itemize}

    \item \textbf{/artifacts/:id (Artefakte - Details):} Liefert Details zu einem spezifischen Artefakt anhand der \texttt{id}.
          \begin{itemize}
              \item \textbf{Dynamisch erzeugt aus:}
                    \begin{itemize}
                        \item \textbf{artifacts/show.tmpl:} Nutzt die Daten eines Artefaktes.
                        \item \textbf{error.tmpl:} Spezifische Fehlermeldung von \textit{Go} nach Datenbankabfrage.
                    \end{itemize}

          \end{itemize}

    \item \textbf{/campaigns (Kampagnen - Index):} Liefert eine Liste aller Kampagnen.
          \begin{itemize}
              \item \textbf{Dynamisch erzeugt aus:}
                    \begin{itemize}
                        \item \textbf{campaigns/index.tmpl:} Nutzt die Daten aller Artefakte und die Werte der Filterparameter.
                    \end{itemize}
          \end{itemize}

    \item \textbf{/campaigns/:id (Kampagnen - Details):} Liefert Details zu einer spezifischen Kampagne anhand der \texttt{id}.
    \item \textbf{Query-Parameter (optional):}
          \begin{itemize}
              \item \texttt{start\_date} - Filtert Kampagnen nach Startzeitpunk.
              \item \texttt{end\_date} - Filtert Kampagnen nach Endzeitpunkt.
          \end{itemize}
          \begin{itemize}
              \item \textbf{Dynamisch erzeugt aus:}
                    \begin{itemize}
                        \item \textbf{campaigns/show.tmpl:} Nutzt die Daten einer Kampagne.
                        \item \textbf{error.tmpl:} Spezifische Fehlermeldung von \textit{Go} nach Datenbankabfrage.
                    \end{itemize}
          \end{itemize}
\end{itemize}

\section{Implementierung von ACEMA}
Die empirische Methode kann auf zwei verschiedenen Arten für das Dashboard genutzt werden. Zum einen lassen sich über die Matrixdaten aus Anhang \ref{app:mapping-dataset} sehr aussagekräftige Diagramme erstellen, die jedoch nicht direkt in die Technik- oder Artefaktdarstellung im Dashboard integriert werden. Zum anderen gibt der Output von \gls{acema} die Möglichkeit, die \gls{cvss} Daten direkt in existierende Seiten des Dashboards zu integieren und den Inhalt aufzuwerten.

\subsection{Anwendung von ACEMA auf die Daten}
\label{sec:impl-anwendungVonAcema}
Der allgemeine Ablauf der Mappings wurde in Kapitel \ref{sec:auswahlDerEmpirischenMethode} bereits angeschnitten. Es wurden zwei Grundvoraussetzungen definiert, die für die erfolgreiche Implementierung von \gls{acema} nötig sind. Die erste Voraussetzung (Zuordnung Angriffsszenario zu \gls{mitre}-Technik) wurde von den Verantwortlichen des \glspl{at} umgesetzt. Die zweite Voraussetzung bedurfte einer manuellen Zuordnung von Techniken zu O-RAN \textit{Threat-IDs}. Diese Zuordnung ist einmal manuell nötig und aufgrund der ausführlichen Beschreibungen der Techniken und \textit{Threat-IDs} gut machbar. Diese Zuordnung ist in die Datenstruktur einer Technik im Dashboard integriert. Eine Technik in der modifizierten Matrix wird wie in Listing \ref{list:def-technique} beispielhaft gezeigt definiert.
\begin{code}[caption=Beispielhafte Definition einer Technik im Dashboard, label={list:def-technique}]
    AddEntryToMap(
        "MS-TA9002",                        // KEY in die Map
        "MS-TA9002",                        // TM4K-ID
        []string{"T1195.002", "T1525"},     // ATT&CK-Technik-IDs
        "Compromised Image In Registry",    // Technik Name
        []string{"initial-access"},         // ATT&CK-Taktik-Namen
        []string{"T-IMG-01"},               // O-RAN Threat-IDs
    )
\end{code}

Ein Export im \verb|csv| Format aller definierten Techniken ist in Anhang \ref{app:mapping-dataset} abgebildet. Dieser Datensatz stellt auch gleichzeitig die Eingangsdatei dar, auf dessen Basis \gls{acema} arbeitet. Der Datenexport wird erzeugt, wenn die Dashboardanwendung gestartet wird.
\par Die Implementierung von \gls{acema} lässt sich in zwei Teile spalten: den \verb|Gathering|-Teil (deutsch: Sammlungsteil) und den \verb|Analysis|-Teil (deutsch: Analyseteil). Es existieren hierfür jeweils eine Datei mit den aufrufbaren Funktionen und eine andere, die die Aufrufe dieser Funktionen tätigt und prozedural ausgeführt wird.

\par Es wurden einige Anpassungen des verfügbaren \gls{acema}-Quellcodes vorgenommen, die den Entwicklungsfluss vereinfachen und Verbesserungen vornehmen. Eine vorgenommene Verbesserung bezieht sich auf die Vollständigkeit des Daten-Mappings. Es wird in Kapitel \ref{sec:limitationen} gezeigt, dass die im Folgenden beschriebene Verbesserung\footnote{Die \gls{acema}-Implementierung in \autocite{klement2023acema} wird als originaler Quellcode bezeichnet, die Veränderung in \autocite{jesseDumpeldownAcema_oranDev} als verbesserter Quellcode.} zu der Schöpfung einer größeren Datenmenge aus dem \gls{cti} Repository führt.
Eine weitere Änderung betrifft die Ausführung der Python Skripte. Die prozeduralen Teile sind im originalen Repository als \verb|jupyter notebooks| (\verb|.ipynb|-Dateien) geschrieben \autocite{klement2023acema,ProjectJupyter}. Diese Dateien wurden zu einfacheren Ausführung in \verb|.py| Dateien konvertiert, sodass sie direkt über die Python-\gls{cli} aufrufbar sind. Eine Ausführung in einem Jupyter Notebook ergibt für das erstmalige Nachvollziehen oder Demonstrationszwecke Sinn, ist aber für die spätere Ausführbarkeit hinderlich.

Der originale Quellcode arbeitet beim Mapping von \gls{mitre}-Technik zu \gls{capec} mit einem \verb|pandas dataframe|. \textit{Pandas} ist eine bekannte Datenanalysebibliothek für Python \autocite{PandasPythonData}. Für das Konvertieren von \gls{stix}-Daten zu einem \verb|dataframe| wird die Funktion \verb|mitreattack.stixToDf| genutzt \autocite{MitreattackpythonMitreattackAttackToExcel}. Es wird dadurch nur der \textit{enterprise-attack}-Teil der \gls{cti} Daten genutzt. Viele Beziehungen zwischen \gls{mitre}-Technik und \gls{capec} finden sich jedoch auch im \textit{capec/2.1/attack-pattern} Teil des Repositories. Diese Limitation bringt signifikant weniger Mappings zum Vorschein, wie empirisch in Kapitel \ref{limitationen-acema} gezeigt wird. Deshalb nutzt die verbesserte Implementierung die Datensätze aus beiden Teilen. Auch wurde ein anderer Ansatz zur Verarbeitung der einzelnen \verb|json|-Dateien angewandt. Anstatt der Konvertierung zu einem mächtigen \verb|dataframe| der alle Daten enthält, werden die \gls{stix}-Daten aus jeder \verb|json|-Datei einzeln geladen und der Inhalt der \gls{stix}-Objekte über \verb|stix_data.get()| ausgelesen \autocite{OasisopenCtipythonstix2OASIS}. Die genaue Abfolge der abgefragten Kriterien bis zum Finden eines Mappings in Abbildung \ref{fig:detailed-mapping} ist als detaillierte Ansicht des Schrittes 1 in Abbildung \ref{fig:mitre_mapping} zu verstehen.

\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=0cm, minimum height=0cm, text centered, draw=black, fill=red!30]
\tikzstyle{process} = [rectangle, minimum width=0cm, minimum height=0cm, text centered, draw=black, fill=blue!30]
\tikzstyle{decision} = [diamond, minimum width=0cm, minimum height=0cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=2.5cm and 3cm]

        % Nodes for processes and start
        \node (start) [startstop] {Start (Loop through Directories)};
        \node (loadJson) [process, below of=start] {Load and Parse JSON};
        \node (processObjects) [process, below of=loadJson] {Process Objects in JSON};
        \node (extractCapec) [process, below of=processObjects, yshift=-7cm] {Extract CAPEC Reference};
        \node (appendCapec) [process, below of=extractCapec] {Append CAPEC ID to Results};

        % Nodes for decisions (aligned left)
        \node (checkType) [decision, left of=start, xshift=-5cm, yshift=-3cm] {Is Object Type `attack-pattern`?};
        \node (checkRef) [decision, below of=checkType, yshift=-5cm] {Is `source\_name` = `capec`};
        \node (checkTechnique) [decision, below of=checkRef, yshift=-5cm] {`external\_id` in Techniques?};

        % Node for Stop and finish
        \node (end) [startstop, right of=checkRef, xshift= +5cm] {End Loop};
        \node (finish) [startstop, below of=appendCapec] {Finished};


        % Arrows from processes to decisions
        \draw [arrow] (processObjects.west) -- (checkType.east);
        \draw [arrow] (start) -- (loadJson);
        \draw [arrow] (loadJson) -- (processObjects);

        % Arrows between decisions
        \draw [arrow] (checkType) -- node[anchor=east] {Yes} (checkRef);
        \draw [arrow] (checkRef) -- node[anchor=east] {Yes} (checkTechnique);

        % Arrows for "No" to End Loop
        \draw [arrow] (checkType.south east) -- node[anchor=east] {No} (end.west);
        \draw [arrow] (checkRef.east) -- node[anchor=east] {No} (end.west);
        \draw [arrow] (checkTechnique.north east) -- node[anchor=east] {No} (end.west);

        % Arrow from last decision to process
        \draw [arrow] (checkTechnique.east) -- node[anchor=east] {Yes} (extractCapec.west);

        % Arrow from processes to the next
        \draw [arrow] (extractCapec) -- (appendCapec);
        \draw [arrow] (appendCapec) -- (finish);

    \end{tikzpicture}
    \caption{Detailansicht des Ablaufs des Mappings von MITRE-Technik zu CAPEC.}
    \label{fig:detailed-mapping}
\end{figure}

Wenn alle Mappings über die verbesserte Implementierung gefunden wurden, werden die Ergebnisse mit den Ergebnissen aus der originalen Implementierung zusammengeführt. Dadurch ergibt sich das komplette Mapping von \gls{mitre}-Technik zu \gls{capec}. Für die anderen Schritte des Mappings wurden keine Verbesserungsmöglichkeiten gefunden, daher sind die Funktionen aus dem originalen Quellcode beibehalten worden. Die Ausgabe der \gls{acema} Ausführung ist eine Datei im \verb|json| Format. Ein beispielhafter Auszug aus dieser Datei ist im Anhang \ref{app:acema-output} dargestellt. Bis zur Erstellung dieser Datei vergingen beim letzten Durchlauf knapp unter 40 Minuten. Das ist der hohen Anzahl der \glspl{cve} geschuldet, für die jeweils eine Anfrage an die \gls{nvd} geschickt wird. Die Dokumentation der \gls{nvd} Schnittstelle empfiehlt eine Wartezeit von sechs Sekunden zwischen Anfragen \autocite{DevelopersStartHere}.
\[353 \text{ CVEs} \cdot 6 \text{ Sekunden Wartezeit} \thickapprox 35 min \]

Der Output des \textit{Gathering} Skripts wird für die Analyse der Daten verwendet, um verschiedene Arten von Diagrammen zu erzeugen. Auf die Erkenntnisse, die man aus diesen Diagrammen gewinnen kann, wird in Kapitel \ref{sec:interpretation-acema} eingegangen. Alle Diagramme können auch im Dashboard angezeigt werden. Dazu wurde die Seite \verb|/acema| erstellt, die alle pdf-Dateien aus dem Ordner \verb|public\data| enthält. Neben den von \citeauthor{klementSecuring6GTransition2024} erstellen Diagrammen wurden drei weitere implementiert, die weitere Insights in die Daten geben. Die Erstellung weiterer Diagramme wird durch die Nutzung bekannter Datenanalyseframeworks und die umfangreiche Dokumentation im Quellcode unterstützt.

\par Aktuell ist es nicht implementiert, die \gls{acema} Python Skripte aus dem Dashboard heraus auszuführen, um eine neue Datensammlung oder Datenauswertung zu starten. Die Änderungsrate der Daten ist zudem eher gering, insofern ist eine Aktualisierung in kleinen Abständen nicht nötig. Die \gls{mitre}-Techniken im Dashboard sind quasi statisch, da sie sich an den implementieren Szenarien des \glspl{at} und dem \gls{attack}-Framework in Version \textit{16.1}orientieren. Insgesamt umfasst die Gesamtmenge aller \glspl{capec} 559 in \gls{capec} Version \textit{3.9}, wobei seit Januar 2023 nur vier neue (+0,7\%) hinzugefügt wurden. Auch die Veränderung im Mapping zwischen \gls{capec} und \gls{cwe} ist gut dokumentiert auf der \gls{capec} Webseite einsehbar. Hier ist eine Veränderung von 59 neu hinzugefügten Mapping in Version \textit{3.9} vor dem Hintergrund der Gesamtmenge auch eine sehr kleine Veränderung. Die Gesamtmenge der \gls{capec}-zu-\gls{cwe}-Mappings lässt sich anhand folgender Daten aus dem Testdatensatz in Anhang \ref{app:mapping-dataset} und dem Wert aus \autocite{CAPECNewsEvents} schätzen:
\[
    \begin{alignedat}{2}
         & \text{Anzahl von CAPEC in Testdatensatz}            & \quad & = 29             \\
         & \text{Anzahl von CWE in Testdatensatz}              & \quad & = 119            \\
         & \text{Durchschnittliche Anzahl von } \frac{\text{CWEs}}{\text{CAPEC}} & \quad & =
        4{,}1                                                                                              \\
        & \text{Gesamtmenge aller CAPECs}                        & \quad & = 559 \\
        & \text{Schätzung der Anzahl der Mappings}                             & \quad & =
         559 \cdot 4{,}1                                                  \\
         &                                                                      &       & \thickapprox2300 \\
    \end{alignedat}
\]
Zu einem ähnlichen Wert von 1700 bis 2800 kommt auch OpenAI ChatGPT 4o, wobei dort mit Werten von 3 bis 5 für die Anzahl der durchschnittlichen \glspl{cwe} pro \gls{capec} gerechnet wird \autocite{openaichatgpt4oCAPECCWEMapping2024}.

Zuletzt muss noch das Mapping von \gls{cwe} zu \gls{cve} betrachtet werden. Die Daten dazu stammen aus der \gls{mitre} \gls{cwe} Liste und werden mehrmals jährlich, ungefähr alle vier Monate aktualisiert \autocite{CWEDownloads,AIWorkingGroupMeeting_slides20241115_CWEAIWGpdf2024}.

Das Mapping zwischen \gls{mitre}-Technik und \glspl{cve} ändert sich infolgedessen nur in geringer Weise. Eine Integration der neuen Daten durch das Ausführen der \gls{acema} Skript und das Kopieren der \verb|json|-Datei in die Dashboardverzeichnisse \verb|pkg\artifacts| und \verb|pkg\mitre| ist demnach nicht kontinuierlich, aber mit einem Abstand von ungefähr vier Monaten, angepasst an die Änderungsrate der \gls{cwe} Liste, empfehlenswert.

\subsection{CVSS Integration} \todo{Hier eventuell noch Umordnung von Kapiteln.}
\label{sec:impl-cvssIntegration}
Eine Integration mit dem \gls{cvss} ist eine grundlegende Funktion für jede Anwendung, die eine Bewertung von Schwachstellen vornimmt. Der \gls{cvss} Wert hilft dabei, schnell einen Überblick über den Schweregrad eines potenziellen Angriffs durch Ausnutzung der spezifischen Schwachstelle zubekommen. Aus diesem Grund hatte die Umsetzung von Beginn an eine hohe Priorität. Ursprünglich sollte die Bewertung nur über manuell zugeordnete \glspl{cve} vorgenommen werden, dieser Ansatz stellte sich allerdings als mühsam und nicht praktikabel heraus. Über die in Kapitel \ref{sec:impl-anwendungVonAcema} beschriebene Implementierung von \gls{acema} war eine deutlich schnellere und automatisierte Anreicherung von Daten mit \glspl{cve} möglich. Die Visualisierung von spezifischen Werten, die sich aus insgesamt sechs \gls{cvss} Metriken zusammensetzen, wurde an zwei Stellen implementiert, die im Folgenden genauer betrachtet werden.
Der in Listing \ref{list:go-embed} dargestellte und im nachfolgenden Kapitel beschriebene \textit{Go} QUellcode arbeiten nicht direkt mit dem originalen Output von \gls{acema} (Dateiname: \verb|t-cwe-cve-dict.json|), sondern mit einer eigens leicht abgewandelten Version, in der nur die für das Dashboard relevanten Daten vorhanden sind. Der abgewandelten Quellcodes sind im Fork \autocite{jesseDumpeldownAcema_oranDev} des Repositories \autocite{klement2023acema} verfügbar. Diese \textit{neue} Datei mit dem Suffix \textit{\_small} wird über das Ausführen von \verb|data_analysis_nb.py| erstellt. Darin sind nur die Daten enthalten, die für die Integration einer Bewertung nach \gls{cvss} nötig sind, wie in Anhang \ref{app:acema-output-small} zu erkennen ist. Die enthaltenen Daten beschränken sich auf \gls{mitre} Technik-ID, \gls{capec}-ID, \gls{cwe}-ID, \gls{cve}-ID, und vier Metriken aus zwei Metrikgruppen die in \gls{cvss}\textit{v2} definiert sind \autocite{CVSSV2Complete}. Details über die Inhalte der Metrikgruppen werden in diesem Kapitel tiefergehend gegeben.

\par Um die Outputdatei mit den relevanten Daten im Dashboard nutzen zu können, wird das Paket \verb|embed| aus der Standard Bibliothek von \textit{Go} genutzt \autocite{EmbedPackageEmbed}. Dies ermöglicht es, auf die Datei zuzugreifen, nachdem das Dashboard Projekt mit \verb|go build cmd/main.go| zu einer Binärdatei kompiliert wurde. Der Quellcode in Listing \ref{list:go-embed} zeigt, wie die Datei in eine Variable gelesen wird, die ein lokales Dateisystem simuliert. Von dort kann die Datei in Objekt in die vorher definierte Liste vom Datentyp \verb|ACEMA_DATA| gelesen werden. Die Variable \verb|ACEMA_DATA.Data| agiert hierbei quasi als \textit{Immutable Object} (deutsch: unveränderliches Objekt), das heißt der Wert der Datei wird während der Laufzeit einmal gesetzt und nicht mehr verändert. Die Sprache \textit{Go} hat keinen eingebauten unveränderlichen Datentyp, der die bei Laufzeit gesetzt werden kann. Außerdem wird die Datei nicht unnötig aus dem Speicher gelesen, wenn die Daten bereits in der Variable vorhanden sind. Die Datenstruktur folgt daher dem \gls{worm}-Prinzip. Ausgelesen werden die Daten mehrfach während der Visualisierung der \gls{cvss} Daten.

\begin{code}[caption=Datei in Binardatei einbetten und in Struktur überführen, label={list:go-embed}]
    //go:embed t-cwe-cve-dict-small.json
    var data_json embed.FS
    if ACEMA_DATA.Data == nil {
        fileData, err := data_json.ReadFile("t-cwe-cve-dict-small.json")
        if err != nil {
                log.Fatal(err)
            }
        err = json.Unmarshal(fileData, &ACEMA_DATA.Data)
        if err != nil {
                log.Fatal(err)
            }
    }
\end{code}


Die Visualisierung von einem durchschnittlichen\footnote{In diesem Kapitel wird über den Durchschnitt von Werten gesprochen, gemeint ist immer das arithmetische Mittel.} \gls{cvss} Wert für eine \gls{tm4k}-Technik in der Matrix ist einer der Anwendungszwecke, die durch das von \gls{acema} erstellte Mapping möglich gemacht wird. Dabei wird für eine Technik der Durchschnitt aller \gls{cvss} \textit{v2\_score} Werte in den zugeordneten \glspl{cve} gebildet (siehe Zeile 1 im Listing \ref{list:mean}).  Wie bereits in Kapitel \ref{limitationen-acema} beschrieben, nutzt \gls{acema} das \gls{cvss} in \textit{Version 2}. Die Metrik \textit{v2\_score} ist dabei ein Wert, der sich aus allen vorhandenen Metriken aus den verschiedenen Metrikgruppen zusammensetzt. In der \textit{Gruppe der Basismetriken} werden die grundlegenden Merkmale einer Schwachstelle bewertet, die sich, im Gegensatz zu Metriken aus der \textit{zeitlichen Gruppe} und der \textit{Umgebungsgruppe}, nicht über die Zeit verändern \autocite{CVSSV2Complete}.

Bei der Ausführung von \verb|data_analysis_nb.py| wird auch für jede \gls{mitre}-Technik die Berechnung der durchschnittlichen \gls{cvss} Werte über alle gefundenen \glspl{cve} durchgeführt. In der Funktion \verb|generate_json_with_scores| werden dazu die jeweiligen Werte in einer Liste gesammelt und mithilfe der Funktion \verb|mean(list[])| aus dem Python Modul \verb|statistics| das arithmetische Mittel berechnet, wie in Listing \ref{list:mean} gezeigt.
\begin{code}[caption=Berechnung des arithmetischen Mittels aus den CVSS Metriken mehrerer CVEs, label={list:mean}]
    new_technique["avg_score"] = statistics.mean(all_v2_scores)
    new_technique["avg_impact_score"] = statistics.mean(all_v2_impact_scores)
    new_technique["avg_exploitability_score"] = statistics.mean(all_v2_exploitability_score)
\end{code}

Die arithmetischen Mittel der Metriken werden daher somit direkt in die \verb|json|-Datei geschrieben und müssen nicht bei einem Neustart des Dashboards neu berechnet werden.

Eine visuelle Darstellung der Berechnung des \textit{Basisscores} ist in Abbildung \ref{fig:calc-cvss} gezeigt. Zu ungefähr 90\% der im Dashboard dargestellten Techniken ist eine \gls{mitre}-Technik zugeordnet und über \gls{acema} können für diese insgesamt 306 relevante \glspl{cve} gefunden werden. Diese Menge an \glspl{cve} bietet eine ausreichende wissenschaftliche Basis zur Auswertung von \gls{cvss} Daten. Es sind keine zu visualisierende Daten verfügbar, wenn entweder keine \glspl{cve} zu der \gls{mitre}-Technik gefunden werden oder keine \gls{mitre}-Technik zu der Technik im Dashboard zugewiesen ist. Zwei Beispiele, eins mit Daten und eines ohne, sind in Abbildung \ref{fig:technik-vis-example} abgebildet.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{technik-vis-example}
    \caption{Visualisierung des Basiswerts für eine Technik}
    \label{fig:technik-vis-example}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{calc-cvss}
    \caption{Einflüsse in der Berechnung des CVSS \textit{Basisscores} über die drei Metrikgruppen}
    \label{fig:calc-cvss}
\end{figure}

\par Eine weitere Anwendung findet die Integration mit \gls{cvss} Daten in der Übersichtsseite eines Artefakts. Die dort angezeigten Werte sind auch wieder Durchschnittswerte, die sich aus den \glspl{cve} zusammensetzen, die genau der einen \gls{mitre}-Technik in diesem Artefakt zugeordnet wurden. Zusätzlich zu dem generellen Durchschnittswert wird in der Detailansicht zwei weitere Wert dargestellt, der die Auswirkung und die Ausnutzbarkeit der zugeordneten \glspl{cve} darstellt. Einer der Werte setzt sich auf drei der Metriken aus der  \textit{Gruppe der Basismetriken} zusammen. Alle \textit{Impact} (deutsch: Auswirkung) Metriken werden zu einem \textit{v2\_impact\_score} zusammengefasst. Der andere Wert stammt aus der zweitlich veränderlichen Metrikgruppe und beschreibt die \textit{Exploitability} (deutsch: Ausnutzbarkeit) der Schwachstelle \autocite{CVSSV2Complete}. Die Bewertung der Ausnutzbarkeit verändert sich zum Beispiel, wenn ein Update für die angreifbare Software veröffentlich wird, die die Sicherheitslücke schließt.
Über die Darstellung der Werte wird eine gute Übersicht der Schwere einer Schwachstelle gegeben. Nach dem Basisscores sind die Angabe der Bewertung der Ausnutzbarkeit und der Auswirkungen die gängigsten Matriken. Die Berechung dieser Werte wird durch die folgenden Formeln ausgedrückt:

\begin{align*}
    \text{Auswirkungen}    & = 10{,}41 \cdot \Big( 1
    - (1 - \text{Vertraulichkeitsverlust}) \notag                                      \\
                           & \quad \cdot (1 - \text{Integritätsverlust})
    \cdot (1 - \text{Verfügbarkeitsverlust}) \Big) \notag                              \\[10pt]
    \text{Ausnutzbarkeit}  & = 20 \cdot \text{Angriffsvektor}
    \cdot \text{Angriffskomplexität} \notag                                            \\
                           & \quad \cdot \text{Authentifizierung} \notag               \\[10pt]
    f(\text{Auswirkungen}) & =
    \begin{cases}
        0,       & \text{wenn Auswirkungen} = 0, \\
        1{,}176, & \text{sonst.}
    \end{cases}                                           \\
    \text{Basisscore}      & = \text{Runden auf 1 Dezimalstelle} \Bigg[ \Big(
    (0{,}6 \cdot \text{Auswirkungen}) \notag                                           \\
                           & \quad + (0{,}4 \cdot \text{Ausnutzbarkeit}) - 1{,}5 \Big)
    \cdot f(\text{Auswirkungen}) \Bigg] \notag                                         \\[10pt]
\end{align*}

\par In beiden Fälle ergänzt eine farbliche Darstellung die numerischen Werte. Die Implementierung im \textit{Go} Quellcode ist in Listing \ref{list:scorecolor} gezeigt. Die Schwellwerte, die ein Spektrum zu einer diskreten Farbe abbilden, können hier angepasst werden. Diese Funktion wird dann über die \verb|template.FuncMap| als Funktion definiert, die direkt in einer \verb|.tmpl| Datei genutzt werden kann. \textit{Go Templates} (deutsch: Vorlagen) werden in \textit{Go} genutzt, um datengesteuert \gls{html}-Seiten mit dynamischen Daten aus einer Datenquelle zu befüllen. Die Datenquellen sind in der Implementierung der das Dashboard Objekte oder eine Liste von Objekten vom Datentyp \verb|Tactic|, \verb|Technique| und \verb|Artifact|. Die Möglichkeit, eine Funktion über \verb|template.FuncMap| verfügbar zu machen, erweitert die Standardfunktionen der Vorlagen-Engine und erlaubt es, komplexe logische Operationen oder Formatierungen direkt im Template auszuführen. Dies führt zu einer klaren Trennung von Logik in \textit{.go} und Darstellung in \textit{.tmpl} Dateien \autocite{TemplatePackageText}.

\begin{code}[caption={Implementierung der farblichen Kategorisierung von Schweregraden}, label={list:scorecolor}]
    func ScoreColor(score float64) string {
            switch {
                    case score > 7.0:
                    return "danger"
                    case score > 3.0:
                    return "warning"
                    case score == 0.0:
                    return "secondary"
                    default:
                    return "success"
                }
        }
\end{code}

Die Darstellung von einzelnen GUI-Elementen wird durch die Nutzung von Bootstrap-Komponenten unterstützt. Bootstrap bietet unter anderem vorgefertigte \textit{Badges} (deutsch: Plaketten) an, die genutzt werden, um zum Beispiel den \gls{cvss} Wert für eine Technik in der Matrix darzustellen. Die Nutzung von \textit{Badges} ist in Abbildung \ref{fig:cvss-colors}, die zugehörige Zeile des Quellcodes in einer Template-Datei ist in Listing \ref{listing:template-cvss} gezeigt \autocite{contributorsmarkottojacobthorntonandbootstrapBadges}.

Die Rückgabe der Funktion \verb|ScoreColor| wird im Template direkt als String in die Definition einer \textit{Badge} eingefügt. So lassen sich vorgefertigte Farben anhand von damit assoziierten Adjektiven (zB.: \(\text{success} = \text{grün}\)) auswählen. Am Beispiel von Listing \ref{listing:template-cvss} wird erkennbar, dass die Funktion \verb|scorecolor| mit dem Attribut \verb|AvgV2Score| eines Artefakts als Parameter aufgerufen wird, dessen Rückgabe die Klasse des \gls{html}-Elements \verb|span| definiert. Der tatsächliche Wert des Attributes wird dann innerhalb des Elements ausgegeben \autocite{HTMLSpanTag}.

\begin{code}[caption=Aufbau eines \gls{html} Elements zur Darstellung eines CVSS Werts in einer Bootstrap Komponente, label={listing:template-cvss}]
    <span class="badge bg-{{ scoreColor .AvgV2Score }}">{{ .AvgV2Score }}</span>
\end{code}

Eine Verwendung weiterer Daten, wie weiterführende Infos über spezifische \glspl{cve} und \glspl{cwe}, die in der originalen \verb|t-cwe-cve-dict.json| Datei vorhanden sind, ist in der aktuellen Version des Dashboards nicht angedacht und daher nicht implementiert.

\section{Visualisierung des Angriffspfads}
\label{sec:impl-visualisierungDesAngriffspfads}
Die Visualisierung des Angriffspfads bietet im Dashboard eine intuitive Darstellung der Angriffssequenzen in Form eines Netzwerks, das durch Icons ergänzt wird. Der Begriff \textit{Netzwerk} meint in diesem Kontext einen gerichteten Graphen (Digraph), also einen Diagram mit Knoten und Kanten, indem die Kanten durch einen Pfeil dargestellt werden, der von einem Knoten auf einen Anderen zeigt \autocite{DigraphDefinition}. Die Darstellung erlaubt eine schnelle Erfassung der kritischen Informationen, indem sie zeigt, welches Gerät mit welchem Software-Werkzeug und welchem ausgeführten Kommando in Verbindung steht, um die Angriffssimulation auszuführen. In der Verkettung werden außerdem die Daten über das genutzte Angriffsmuster (\gls{capec}), Schwachstellenkategorie (\gls{cwe}) und letztendlich die spezifische Schwachstelle (\gls{cve}) visualisiert. Das Ergebnis ist in Abbildung \ref{fig:attack-graph} gezeigt.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{attack-graph}
    \caption{Visualisierung eines Angriffspfads}
    \label{fig:attack-graph}
\end{figure}

\par Ein Teil der Informationen stammt direkt aus dem Angriffstool und wird aus der Datenbank gelesen. Dazu gehört zum einen der Gerätename, auf dem das \gls{at} ausgeführt wird. Wenn ein Angriff über die \gls{cli} eines Tools ausgeführt wird, ist der Name dieses Tools in der Datenbank hinterlegt, sowie das Kommando, dass die Ausführung des Angriffes startet. Diese Informationen müssen nicht zwangweise hinterlegt sein, sind aber in den meisten Fällen vorhanden. Über den Wert das Feldes \verb|tool_name| kann in der Übersicht aller Artefakte gefiltert werden.
\par Ein anderer Teil wird aus den \gls{acema} Daten zugeordnet. Alle relevanten Daten werden, wie in Listing \ref{list:go-embed} gezeigt, in der Funktion \verb|InitACEMA()|in eine Liste von Objekten vom Typ \verb|ACEMA_DATA| geladen. Wenn dem Artefakt über die Datenbank eine \gls{mitre}-Technik zugeordnet wurde, werden diese Daten nach dieser \verb|technique_id| durchsucht und bei dem \textit{ersten Match} \gls{capec} und \gls{cwe} zugeordnet. Diese Logik ist in der Funktion \verb|AddACEMA()| zu finden. Im \gls{acema}-Datensatz, der aktuell im Dashboard verwendet wird, ist es in weniger als 15\% der Fälle so, dass mehrere \glspl{capec} zu einer \gls{mitre}Technik gefunden werden. Häufiger (vgl. Schätzung aus Kapitel \ref{sec:impl-anwendungVonAcema}) kommt es vor, dass einem \gls{capec} mehrere \glspl{cwe} zugeordnet sind. Da nach dem Prinzip \textit{erster Match} die Daten für die Angriffspfadvisualisierung gesucht werden, ist diese Zuordnung mit Vorsicht zu genießen. Insbesonderes ist es wichtig dabei zu beachten ist, dass keine spezifischen \glspl{cve} zugeordnet werden, da hier die Fehlerrate über den \textit{ersten Match} noch größere wäre. Über \gls{acema} wird eine generelle Menge an möglichen \glspl{cve} gefunden, welcher spezifische \gls{cve} letztendlich von dem jeweiligen Tool ausgenutzt wird, kann darüber nicht klar zugeordnet werden. Um eine genaue Zuordnung herzustellen, ist ein manueller Eintrag vom \gls{at} in das Feld \verb|cve| des jeweiligen Artefakts nötig. Für die Daten \gls{capec} und \gls{cwe} wird dieses Risiko der möglicherweise ungenauen Zuordnung eingegangen, da es sich nicht um hochkritische Daten handelt. Zwischen \glspl{capec} und \glspl{cwe} die einer \gls{mitre}-Technik zugeordnet sind, ist immer eine deutliche Ähnlichkeit zu erkennen.
\par Für die textbasierte Erstellung von Diagrammen wird in wissenschaftlichen Kreis oft die quell-offene Software \textit{GraphViz} und ihre standardisierte \gls{dot} Skriptsprache verwendet. Mithilfe dieser Tools ist es möglich, auf eine flexible und klare Weise  Diagramme textuell zu definieren und in wissenschaftliche Arbeitsschritte zu integrieren \autocite{Graphviz,DOTLanguage}. Im Dashboard wurde die Erstellung von Graphen im \gls{dot} Format genutzt, da sich ein einfacher Graph innerhalb weniger Zeilen ausdrücken lässt und es \gls{js} Pakete gibt, die die Umwandlung von Text zu Graph komfortabel zulassen.
\par Die Erstellung eines \gls{dot}-Graphen in \gls{html} erfolgt in mehreren Schritten, um eine dynamische und visuelle Darstellung zu ermöglichen. Voraussetzung ist, dass die zu visualisierenden Daten des Artefakts in der Datenbank existieren. Außerdem ist die Vorlage des Graphen als ein \textit{Go} String definiert. Diese Vorlage dient als Grundgerüst für den Graphen und enthält Platzhalter, die später durch spezifische Daten gefüllt werden. Die Struktur des Templates ist so gestaltet, dass sie die grundlegenden Elemente eines \gls{dot}-Graphen, wie Knoten, Kanten und Attribute, klar definiert. In Abbildung \ref{fig:vis-graph-steps} ist der Prozess visuell dargestellt. Der Fluss der Daten ist dort mit Pfeilen dargestellt, die Blöcke beschreiben die durchgeführten Aktionen in der jeweiligen Umgebung.
\par Der Prozess beginnt mit dem Auslesen der Daten aus der Datenbank, sobald die Detailseite eines Artefakts aufgerufen wird. Bei jedem Aufruf der Seite wird der Graph neu erstellt, um auf aktualisierte Daten reagieren zu können. Die Artefaktdaten existieren jetzt als ein Objekt in \textit{Go} und können zum dynamischen Füllen der Lücken im \gls{dot}-Template genutzt weden. Dadurch entsteht ein individuell angepasster \gls{dot}-Graph, der die spezifischen Daten widerspiegelt.
\par Der dritte Schritt umfasst die Übergabe der gefüllten Daten an das Go-Template \verb|artifacts/show.tmpl|. Die Übergabe der Daten erfolgt mithilfe des Web-Frameworks \textit{Gin}. Dieses \textit{Go}-Template ist für die Generierung des finalen \gls{html}-Codes zuständig, der den \gls{dot}-Graph enthält \autocite{GingonicGinGin}.
\par Anschließend werden im vierten Schritt die Daten aus den übergebenen Variablen gelesen und in die für \textit{Hotwire Stimulus} benötigten Felder eingefügt, um sie später in \gls{js} weiterverarbeiten zu können. Die Daten werden dabei als Werte in \gls{html}-Attributen gesetzt und sind nicht direkt für den Nutzer sichtbar. \textit{Stimulus} benötigt hierbei Daten im Attribut \verb|data-xxx-value|. Dieses Attribut enthält den \gls{dot}-String. Außerdem wird in \verb|data-xxx-target| der Name des \gls{html}-Elements definiert, der als Zielcontainer für die Visualisierung des Graphen dient. Der \gls{js}-Controller von Hotwire sorgt dafür, dass die Daten dynamisch an das Zielelement übergeben werden, wodurch die Interaktivität der Darstellung gewährleistet wird \autocite{StimulusReference}.
\par Im letzten Schritt übernimmt der \gls{js}-Controller, in diesem Fall vis\_controller.js, die Verantwortung. Dieser liest den dynamisch generierten \gls{dot}-String aus dem \gls{html}-Attribut aus und verarbeitet sie mit der Funktion \verb|parseDOTNetwork| aus dem \gls{js}-Paket vis-network weiter. Dieses Paket wandelt den \gls{dot}-Quellcode in eine visuelle Graphenstruktur um, die anschließend in das Zielelement gerendert wird. Durch die Verwendung von vis-network wird eine Darstellung gewährleistet, die es dem Nutzer erlaubt mit dem Graphen zu interagieren \autocite{VisjsVisnetwork2024}. Detailierte Informationen zu den Funktionen des Graphen wurden in Kapitel \ref{sec:auswahlDerVisualisierungstechniken} gegeben.
\par Insgesamt bietet dieser Prozess eine effiziente Methode, um \gls{dot}-Quellcode dynamisch zu erstellen, in \gls{js} zu interaktiven Graphen zu verarbeiten und in \gls{html} visuell darzustellen.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=2cm, auto]

        % Nodes
        \node (start) [rectangle, draw, text centered] {Daten existieren in Datenbank};
        \node (process1) [rectangle, draw,below of=start] {Dynamisches Füllen der Lücken im \gls{dot}-Template};
        \node (process2) [rectangle, draw,below of=process1] {Setzen von \textit{Hotwire Stimulus} \verb|value| und \verb|target|};
        \node (process3) [rectangle, draw,below of=process2] {\textit{\gls{html}} ist Transfermedium der Daten};
        \node (process4) [rectangle, draw,below of=process3] {Verarbeitung von \gls{dot} zu \textit{Vis Network}};
        \node (stop) [rectangle, draw,below of=process4] {Visualisierung des Graphen};

        % Arrows
        \draw [->, thick] (start) -- (process1) node[midway, left] {Schritt 1: \textit{Datenbank} nach \textit{Go}};
        \draw [->, thick] (process1) -- (process2) node[midway, right] {Schritt 2: \textit{Go} nach \textit{Go Template}};
        \draw [->, thick] (process2) -- (process3) node[midway, left] {Schritt 3: \textit{Go Template} nach \textit{\gls{html}-Attribut}};
        \draw [->, thick] (process3) -- (process4) node[midway, right] {Schritt 4: \textit{\gls{html}-Attribut} nach \textit{\gls{js}}};
        \draw [->, thick] (process4) -- (stop) node[midway, left] {Schritt 5: \textit{\gls{js}} nach \textit{\gls{html}-Element}};

    \end{tikzpicture}
    \caption{Schritte zur Erstellung des Graphen}
    \label{fig:vis-graph-steps}
\end{figure}

\section{Sonstige Implementierungen}
\label{sec:impl-others}
Neben den bereits genannten Themen, wurden viele weitere kleinere Änderungen am Dashboard vorgenommen, um die Funktionalität und die Benutzererfahrung zu verbessern. Auf eine Auswahl dieser sonstigen Verbesserungen wird in diesem Kapitel eingegangen.
\subsection{Weiterführende Informationen zu Techniken}
\par Wie in Kapitel \ref{sec:datenquellen} beschrieben, bieten sich drei wissenschaftliche Konstruktur an, aus denen Techniken in die Matrix im Dashboard übernommen werden können. Bis auf zwei Techniken können alle im Dashboard angezeigten Techniken mindestens zwei Techniken aus \gls{tm4k}, \gls{mitre} \gls{attack} Matrix oder dem \gls{wg11} Report zugeordnet werden. Wie in \ref{sec:impl-anwendungVonAcema} beschrieben, wurde diese Zuweisung über einen Vergleich der Beschreibungen der jeweiligen Techniken manuell vorgenommen.
Um diese Zuweisungen nicht nur ohne weitere Funktion textuell darzustellen, wurde eine Verlinkung zu weiterführenden Informationen auf den Seiten \autocite{MITREATTCK} und \autocite{TacticsThreatMatrix} hinzugefügt. Eine Onlinequelle zu den O-RAN Bedrohungen gibt es bisher nicht, diese sind alleine in einem Microsoft Word Dokument veröffentlicht. Die URL, an die nach einem Klick weitergeleitet wird, ist dynamisch aus den Daten der Technik zusammengesetzt. Für die \gls{mitre} \gls{attack} Webseite setzt sich die URL so zusammen: \par \verb|attack.mitre.org/techniques/{Technik-ID}/{Subtechnik-ID}|
\par Microsofts \gls{tm4k} Seite nutzt für die URLs nicht die eindeutige ID, sondern den Titel der Technik. Die URL kann also wie folgt definiert werden: \par \verb|microsoft.github.io/Threat-Matrix-for-Kubernetes/techniques/{Technik-Titel}|
\par Die Zuordnung zu den Quellen wird auch farblich gekennzeichnet. Wenn kein Wert angezeigt wird, ist keine weitere Zuordnung möglich.
\subsection{Verbesserung der Zeitleiste}
Die Zeitleiste ist ein wichtiges Feature im Dashboard. Es zeigt visuell aufbereitet, in welchem Zeitraum ein Angriff ausgeführt wurde. Es bringt jedoch auch einige technische Herausforderungen mit sich, auf die ich im Folgenden eingehe.
\par Ein Angriff dauert in der Regel nur wenige Sekunden, eine Darstellung auf einer Zeitleiste die mehrere Stunden oder Tage umfasst ist daher schwierig. Das \gls{js} Framework \textit{Apexcharts.js}, welches für die Visualisierung der Zeitleisten verwendet wird, bietet eine Funktion die es erlaubt, auch kleinste zeitliche Abschnitte in einem großen Zeitraum zu erkennen. Die Funktion fügt zum Start- und Endzeitpunkt eines Angriffs jeweils einen Punkt hinzu, dessen Größe nicht mit der Dauer des Angriffs skaliert. In einer Übersicht über mehrere Stunden oder Tage ist jedes Artefakt mit einem gleichgroßen Punkt gekennzeichnet. Eine detailierte Ansicht kann dann über die Zoomfunktion erreicht werden. Dabei kann direkt in der Zeitliste durch \textit{Klicken-und-Ziehen} der Maus eine Zeitspanne ausgewählt werden. Diese beiden Funktionen werden über die Konfiguration in der Datei \verb|assets\js\controllers\timeline_controller.js| aktiviert.
\par Bei der Darstellung von einer großen Menge von Artefakten auf der Zeitleiste ist eine deutliche Einbuse der Performance zu spüren. Über subjektives Empfinden wurde eine Grenze von 100 Artefakten gefunden, bis zu der die Visualisierung ohne merkliche Verzögerung möglich ist. Die Begrenzung wird im Logik Teil der Anwendung angewendet, bevor die Daten überhaupt vom Server in die \gls{html} Datei eingebettet werden. Die Datenbankabfrage sortiert die Daten absteigend nach Startdatum, es werden daher die 100 Artefakte angezeigt, die die Daten der zuletzt ausgeführten Angriffe enthalten \autocite{bibid}. Der dazugehörige Quellcode ist in Listing \ref{list:go-sort} dargestellt.
\begin{code}[caption=Sortierung der Datenbankobjekte, label={list:go-sort}]
    options.Find().SetSort(bson.D{{Key: "timestamp_start", Value: -1}})
\end{code}

\subsection{Vereinfachung der Datenstruktur eines Artefakts}
Über den Zeitraum der Implementierung haben sich nicht wenige Änderungen in der Datenstruktur eines Artefakts ergeben. In einer NoSQL Datenbank muss prinzipiell keine feste Struktur vorhanden sein, ist jedoch für das Auslesen eines Objekts in die definierte Datenstruktur in \textit{Go} nötig. Da die Serialisierung von Python zu JSON in einer anderen Anwendung und von anderen Personen implementiert wurde als die Deserialisierung von JSON zu Go, war eine Absprache von großer Wichtigkeit. So wurde aus dem Feld \verb|mitre| mit Datentyp \verb|String| zuerst eine Liste um auch eine Zuordnung zu mehreren \gls{mitre} Techniken abbilden zu können. Später wurden alle Informationen über Techniken und Taktik in ein Feld vereint. Das Feld \verb|command| wurde angepasst, um die Ausführung mehrerer Kommandos während eines Angriffs modellieren zu können. Weitere kleinere Änderungen führten zu dem Schema, welches im Anhang \ref{app:db-schema} dargestellt ist. Eine Erweitung dieses Schemas ist einfach möglich. Das hinzugekommene Feld muss dafür in der Datei \verb|pkg\artifacts\model.go| in der \verb|struct| Definition eines Artefakts hinzugefügt werden, wie in Listing \ref{list:new-field} demonstriert ist.
\begin{code}[caption=Hinzufügen eines Feldes zum Schema in \textit{Go}, label={list:new-field}]
    type Artifact struct {
            ID          primitive.ObjectID  `bson:"_id" json:"id"`
            IP          string              `bson:"ip" json:"ip"`
            ...
            NewField    float64             `bson:"new_field" json:"new_field"`
        }
\end{code}